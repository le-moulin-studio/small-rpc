package com.lemoulinstudio.small.jse;

import com.lemoulinstudio.small.common.LocalService;
import com.lemoulinstudio.small.common.MessageSender;
import com.lemoulinstudio.small.common.RemoteService;
import com.lemoulinstudio.small.utils.ByteBufferInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.logging.Logger;
import java.util.HashMap;

/**
 * An implementation of the {@link SmallSession} interface.
 * 
 * @author Vincent Cantin
 */
public class SmallSessionImpl implements SmallSession {

  private Map<Class<? extends LocalService>, LocalService> interfaceToService;
  private Map<LocalService, Class<? extends LocalService>> serviceToInterface;
  
  private Map<Class<? extends RemoteService>, RemoteService> interfaceToProxy;
  private Map<RemoteService, Class<? extends RemoteService>> proxyToInterface;

  private ProxyFactory proxyFactory;
  private RootDecoder rootDecoder;

  private MessageSender messageSender;
  private Object callerObject;

  private static final Logger logger = Logger.getLogger(SmallSessionImpl.class.getName());

  /**
   * Creates a Small session.
   *
   * @param config An instance of the configuration class generated by the annotation processor.
   */
  public SmallSessionImpl(AbstractConfiguration config) {
    interfaceToService = new HashMap<Class<? extends LocalService>, LocalService>();
    serviceToInterface = new HashMap<LocalService, Class<? extends LocalService>>();
    
    interfaceToProxy = new HashMap<Class<? extends RemoteService>, RemoteService>();
    proxyToInterface = new HashMap<RemoteService, Class<? extends RemoteService>>();

    proxyFactory = new ProxyFactoryImpl(config.getRemoteClassToProxyClass());
    rootDecoder = config.getRootDecoder();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void decodeAndExecute(ByteBuffer binaryMessage) throws Exception {
    DataInputStream inputStream = new DataInputStream(new ByteBufferInputStream(binaryMessage));

    // Decode the message and invoke the method.
    rootDecoder.decodeAndInvoke(this, inputStream);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void setMessageSender(MessageSender messageSender) {
    this.messageSender = messageSender;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void setCallerObject(Object callerObject) {
    this.callerObject = callerObject;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Object getCallerObject() {
    return callerObject;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends LocalService> void bind(T service, Class<T> serviceInterface) {
    assert !interfaceToService.containsKey(serviceInterface) : "A service instance is already registered for this class.";
    interfaceToService.put(serviceInterface, service);
    serviceToInterface.put(service, serviceInterface);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void unbind(LocalService service) {
    Class<? extends LocalService> serviceInterface = serviceToInterface.remove(service);
    assert serviceInterface != null : "This service instance is not bound.";
    interfaceToService.remove(serviceInterface);
  }
  
  /**
   * Used by the decoder.
   * @param <T> The type of the local service.
   * @param serviceInterface the class object of the local service.
   * @return The local service, or <code>null</code> if not found.
   */
  public <T extends LocalService> T getLocalService(Class<T> serviceInterface) {
    return (T) interfaceToService.get(serviceInterface);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends RemoteService> T createProxy(Class<T> serviceInterface) {
    assert !interfaceToProxy.containsKey(serviceInterface) : "There is already a proxy created for to this interface.";
    T proxy = proxyFactory.createProxy(this, serviceInterface);
    proxyToInterface.put(proxy, serviceInterface);
    interfaceToProxy.put(serviceInterface, proxy);
    return proxy;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends RemoteService> void releaseProxy(T proxy) {
    Class<? extends RemoteService> proxyInterface = proxyToInterface.remove(proxy);
    assert proxyInterface != null : "This proxy is not bound to a RemoteService interface.";
    interfaceToProxy.remove(proxyInterface);
  }

  /**
   * This should be only called from a generated proxy.
   */
  // TODO: this could be simplified.
  public void sendMessage(ByteArrayOutputStream byteArrayStream) {
    messageSender.sendMessage(ByteBuffer.wrap(byteArrayStream.toByteArray()));
  }

  /**
   * Logs a text using the default logger of this session.
   *
   * @param text The text to be logged.
   */
  public void logText(String text) {
    logger.info(text);
  }

}
