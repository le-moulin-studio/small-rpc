package com.lemoulinstudio.small.jse;

import com.lemoulinstudio.small.common.BindToLocalId;
import com.lemoulinstudio.small.common.BindToSharedId;
import com.lemoulinstudio.small.common.Local;
import com.lemoulinstudio.small.common.MessageListener;
import com.lemoulinstudio.small.common.Remote;
import com.lemoulinstudio.small.common.Singleton;
import com.lemoulinstudio.small.utils.ByteBufferInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.logging.Logger;
import java.util.HashMap;

/**
 * An implementation of the {@link SmallSession} interface.
 * 
 * @author Vincent Cantin
 */
public class SmallSessionImpl implements SmallSession {

  private Map<Class<? extends Singleton>, Singleton> singletonClassToSingleton;
  private Map<Singleton, Class<? extends Singleton>> singletonToSingletonClass;

  private static LocalIdStore sharedIdStore = new SharedIdStore();
  private static IdObjectBinding<BindToSharedId> sharedIdObjectBinding = new IdObjectBindingImpl<BindToSharedId>();

  private LocalIdStore localIdStore;
  private IdObjectBinding<BindToLocalId> localIdObjectBinding;
  
  private RemoteIdStore remoteIdStore;
  private IdObjectBinding<Remote> remoteIdObjectBinding;

  private ProxyFactory proxyFactory;
  private RootDecoder rootDecoder;

  private Map<Class<? extends Remote>, ViewFactory> remoteClassToViewFactory;
  private Map<Remote, View> proxyToView;

  private MessageListener messageListener;
  private Object callerObject;

  private static final Logger logger = Logger.getLogger(SmallSessionImpl.class.getName());

  /**
   * Creates a Small session.
   *
   * @param config An instance of the config class generated by the annotation processor.
   */
  public SmallSessionImpl(AbstractConfiguration config) {
    singletonClassToSingleton = new HashMap<Class<? extends Singleton>, Singleton>();
    singletonToSingletonClass = new HashMap<Singleton, Class<? extends Singleton>>();

    localIdStore = new LocalIdStoreImpl();
    localIdObjectBinding = new IdObjectBindingImpl<BindToLocalId>();

    remoteIdStore = new RemoteIdStoreImpl();
    remoteIdObjectBinding = new IdObjectBindingImpl<Remote>();

    proxyFactory = new ProxyFactoryImpl(config.getRemoteClassToProxyClass());
    rootDecoder = config.getRootDecoder();

    remoteClassToViewFactory = new HashMap<Class<? extends Remote>, ViewFactory>();
    proxyToView = new IdentityHashMap<Remote, View>();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void decodeAndExecute(ByteBuffer binaryMessage) {
    DataInputStream inputStream = new DataInputStream(new ByteBufferInputStream(binaryMessage));

    // Decode the message and invoke the method.
    try {rootDecoder.decodeAndInvoke(this, inputStream);}
    catch (Exception e) {e.printStackTrace();}
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void setMessageListener(MessageListener messageListener) {
    this.messageListener = messageListener;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void setCallerObject(Object callerObject) {
    this.callerObject = callerObject;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Object getCallerObject() {
    return callerObject;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void registerViewFactory(ViewFactory<?> viewFactory) {
    remoteClassToViewFactory.put(viewFactory.getViewedObjectClass(), viewFactory);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void registerView(View<?> view) {
    proxyToView.put(view.getViewedObject(), view);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void unregisterView(View<?> view) {
    proxyToView.remove(view.getViewedObject());
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends Singleton & Local> void bind(T localObject, Class<T> localInterface) {
    assert !singletonClassToSingleton.containsKey(localInterface) : "A singleton is already registered for this class.";
    singletonClassToSingleton.put(localInterface, localObject);
    singletonToSingletonClass.put(localObject, localInterface);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToSharedId & Local> void bind(T localObject, Class<T> localInterface) {
    Id sharedId = sharedIdStore.createId();
    sharedIdObjectBinding.bind(sharedId, localObject);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToLocalId & Local> void bind(T localObject, Class<T> localInterface) {
    Id localId = localIdStore.createId();
    localIdObjectBinding.bind(localId, localObject);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends Singleton & Local> void unbind(T localObject) {
    Class<? extends Singleton> singletonClass = singletonToSingletonClass.remove(localObject);
    assert singletonClass != null : "This singleton is not bound.";
    singletonClassToSingleton.remove(singletonClass);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToSharedId & Local> void unbind(T localObject) {
    Id id = sharedIdObjectBinding.unbindFromObject(localObject);
    sharedIdStore.releaseId(id);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToLocalId & Local> void unbind(T localObject) {
    Id id = localIdObjectBinding.unbindFromObject(localObject);
    localIdStore.releaseId(id);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends Singleton & Remote> T createProxy(Class<T> remoteInterface) {
    assert !singletonClassToSingleton.containsKey(remoteInterface) : "There is already a singleton bound to this class.";
    T proxy = proxyFactory.createProxy(this, remoteInterface);
    singletonToSingletonClass.put(proxy, remoteInterface);
    singletonClassToSingleton.put(remoteInterface, proxy);
    return proxy;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToLocalId & Remote> T createProxy(Class<T> remoteInterface) {
    return createProxy(remoteInterface, remoteIdStore.allocateNewId());
  }

  private <T extends Remote> T createProxy(Class<T> remoteInterface, Id id) {
    T proxy = proxyFactory.createProxy(this, remoteInterface);
    remoteIdObjectBinding.bind(id, proxy);
    return proxy;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends Singleton & Remote> void releaseProxy(T proxy) {
    Class<? extends Singleton> singletonClass = singletonToSingletonClass.remove(proxy);
    assert singletonClass != null : "This proxy is not bound to a singleton class.";
    singletonClassToSingleton.remove(singletonClass);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToSharedId & Remote> void releaseProxy(T proxy) {
    Id id = remoteIdObjectBinding.unbindFromObject(proxy);
    remoteIdStore.releaseId(id);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public <T extends BindToLocalId & Remote> void releaseProxy(T proxy) {
    Id id = remoteIdObjectBinding.unbindFromObject(proxy);
    remoteIdStore.releaseId(id);
  }

  private void encodeObjectId(Id id, DataOutput output) throws IOException {
    output.writeInt(id.getValue());
  }
  
  private Id decodeObjectId(DataInput input) throws IOException {
    return new Id(input.readInt());
  }

  /**
   * This should be only called from a generated proxy.
   */
  public <T extends BindToSharedId & Local> void encodeObjectSharedId(T object, DataOutput output) throws IOException {
    // Find the associated Id.
    Id id = sharedIdObjectBinding.getId(object);
    assert id != null : "The object is not bound.";

    // Encode it in the output.
    encodeObjectId(id, output);
  }

  /**
   * This should be only called from a generated proxy.
   */
  public <T extends BindToLocalId & Local> void encodeObjectLocalId(T object, DataOutput output) throws IOException {
    // Find the associated Id.
    Id id = localIdObjectBinding.getId(object);
    assert id != null : "The object is not bound.";

    // Encode it in the output.
    encodeObjectId(id, output);
  }

  /**
   * This should be only called from a generated proxy.
   */
  public <T extends Remote> void encodeRemoteObjectRef(T object, DataOutput output) throws IOException {
    // Find the associated Id.
    Id id = remoteIdObjectBinding.getId(object);
    assert id != null : "The object is not bound.";

    // Encode it in the output.
    encodeObjectId(id, output);
  }

  /**
   * This should be only called from a generated proxy.
   */
  public void encodeViewRef(View<?> view, DataOutput output) throws IOException {
    assert view.getViewedObject() != null : "The viewed object is null.";
    encodeRemoteObjectRef(view.getViewedObject(), output);
  }

  /**
   * This should be only called from a generated proxy.
   */
  public void sendMessage(ByteArrayOutputStream byteArrayStream) {
    messageListener.notifyMessage(ByteBuffer.wrap(byteArrayStream.toByteArray()));
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends Local & Singleton> T getLocalSingletonRef(Class<T> singletonClass) throws IOException {
    assert singletonClassToSingleton.containsKey(singletonClass) : "No singleton is bound to this class.";
    return (T) singletonClassToSingleton.get(singletonClass);
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends Remote & Singleton> T getRemoteSingletonRef(Class<T> singletonClass) throws IOException {
    T singleton = (T) singletonClassToSingleton.get(singletonClass);
    if (singleton == null) singleton = createProxy(singletonClass);
    return singleton;
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends BindToSharedId & Local> T decodeObjectSharedId(DataInput input, Class<T> localClass) throws IOException {
    Id id = decodeObjectId(input);
    assert sharedIdObjectBinding.isUsing(id) : "No object is bound to this id.";
    return (T) sharedIdObjectBinding.getObject(id);
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends BindToLocalId & Local> T decodeObjectLocalId(DataInput input, Class<T> localClass) throws IOException {
    Id id = decodeObjectId(input);
    assert localIdObjectBinding.isUsing(id) : "No object is bound to this id.";
    return (T) localIdObjectBinding.getObject(id);
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends Remote> T decodeRemoteObjectRef(DataInput input, Class<T> remoteClass) throws IOException {
    // Decode the Id from the input.
    Id id = decodeObjectId(input);

    // Find the associated object and its class.
    Remote object = remoteIdObjectBinding.getObject(id);
    if (object != null) return (T) object;

    // If not found, create a proxy.
    else return createProxy(remoteClass, id);
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends Singleton & Remote> View<T> decodeSingletonViewRef(DataInput input, Class<T> remoteClass) throws IOException {
    T proxy = getRemoteSingletonRef(remoteClass);
    return getViewRef(proxy, remoteClass);
  }

  /**
   * This should be only called from a generated decoder.
   */
  public <T extends Remote> View<T> decodeViewRef(DataInput input, Class<T> remoteClass) throws IOException {
    T proxy = decodeRemoteObjectRef(input, remoteClass);
    return getViewRef(proxy, remoteClass);
  }

  private <T extends Remote> View<T> getViewRef(T proxy, Class<T> remoteClass) throws IOException {
    if (proxyToView.containsKey(proxy)) {
      return proxyToView.get(proxy);
    }
    else {
      assert remoteClassToViewFactory.containsKey(remoteClass) : "No factory is registered for the class " + remoteClass.getName() + ".";
      ViewFactory viewFactory = remoteClassToViewFactory.get(remoteClass);
      View view = viewFactory.createView(proxy);
      registerView(view);
      return view;
    }
  }

  /**
   * Logs a text using the default logger of this session.
   *
   * @param text The text to be logged.
   */
  public void logText(String text) {
    logger.info(text);
  }

}
